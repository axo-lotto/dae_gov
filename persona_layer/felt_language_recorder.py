"""
Felt Language Recorder - Phase 1 of Language Emergence Strategy
==================================================================

PARALLEL TO DAE 3.0 HEBBIAN LEARNING:
- DAE 3.0: Records (grid_state → value_transformation) pairs
- Language: Records (felt_state → LLM_emission) pairs

PURPOSE:
Record LLM-generated language with complete 57D felt-state signatures to enable
organic family discovery and template extraction in later phases.

ARCHITECTURE:
- 57D Signature: 11 organs × 4D (activation, intensity, polarity, confidence)
                 + 13D context (v0, zone, polyvagal, etc.)
- Cosine similarity clustering (Phase 2)
- Template extraction (Phase 3)
- Organic generation (Phase 4)

EXPECTED TRAJECTORY (from DAE 3.0):
- Epoch 3: 90-150 examples accumulated
- Epoch 7: 210-270 examples, ready for family discovery
- Epoch 10: 300+ examples, first families emerging

Created: November 15, 2025
Strategy: FELT_LANGUAGE_EMERGENCE_STRATEGY_NOV15_2025.md
"""

import json
import numpy as np
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict


@dataclass
class FeltLanguageRecord:
    """Single (felt_state → language) training example."""

    # Unique identifier
    record_id: str
    timestamp: str
    epoch: int
    conversation_id: str
    turn_number: int

    # 57D felt-state signature (parallel to DAE 3.0)
    felt_signature: List[float]  # 57 dimensions

    # LLM-generated language output
    language_output: str

    # Success metrics (for future filtering/weighting)
    success_metrics: Dict[str, float]

    # Metadata for analysis
    metadata: Dict[str, Any]


class FeltLanguageRecorder:
    """
    Records LLM-generated language with complete felt-state signatures.

    Parallel to DAE 3.0's Hebbian coupling matrix:
    - DAE 3.0: H(i,j) ← H(i,j) + η · δ(i,j) · S
    - Language: Store (felt_state_57D, llm_output, satisfaction)

    Phase 1 (Epoch 1-3): Accumulate 90-270 examples
    Phase 2 (Epoch 4-7): Family discovery via clustering
    Phase 3 (Epoch 8-10): Template extraction
    Phase 4 (Epoch 11+): Organic generation
    """

    ORGAN_NAMES = [
        'LISTENING', 'EMPATHY', 'WISDOM', 'AUTHENTICITY', 'PRESENCE',
        'BOND', 'SANS', 'NDAM', 'RNX', 'EO', 'CARD'
    ]

    def __init__(self, storage_path: Optional[str] = None):
        """
        Initialize recorder with persistent storage.

        Args:
            storage_path: Path to JSON file for persistent storage
                         Default: persona_layer/state/active/felt_language_memory.json
        """
        if storage_path is None:
            base_path = Path(__file__).parent / "state" / "active"
            base_path.mkdir(parents=True, exist_ok=True)
            storage_path = str(base_path / "felt_language_memory.json")

        self.storage_path = storage_path
        self.memory: List[FeltLanguageRecord] = self._load_memory()

    def record_llm_emission(
        self,
        felt_state: Dict[str, Any],
        llm_output: str,
        success_metrics: Dict[str, float],
        conversation_id: str = "default",
        turn_number: int = 0
    ) -> FeltLanguageRecord:
        """
        Record a single LLM emission with its felt-state context.

        Args:
            felt_state: Complete felt-state dictionary containing:
                - organ_coherences: Dict[str, float]
                - organ_intensities: Dict[str, float] (optional)
                - organ_polarities: Dict[str, float] (optional)
                - organ_confidences: Dict[str, float] (optional)
                - v0_energy: float
                - satisfaction: float
                - zone: int (1-5)
                - polyvagal_state: str ('ventral', 'sympathetic', 'dorsal')
                - meta_atom_count: int
                - nexus_count: int
                - field_coherence: float
                - signal_inflation: float (optional)
                - temporal_collapse: float (optional)
                - safety_gradient: float (optional)
                - convergence_cycles: int (optional)
                - epoch: int (optional)

            llm_output: The actual language generated by LLM

            success_metrics: Quality metrics:
                - confidence: float
                - satisfaction: float
                - coherence: float

            conversation_id: Unique conversation identifier
            turn_number: Turn within conversation

        Returns:
            FeltLanguageRecord: The recorded entry
        """
        # Compute 57D signature
        felt_signature = self._compute_57d_signature(felt_state)

        # Create record
        record = FeltLanguageRecord(
            record_id=f"{conversation_id}_{turn_number}_{datetime.now().strftime('%Y%m%d%H%M%S%f')}",
            timestamp=datetime.now().isoformat(),
            epoch=felt_state.get('epoch', 0),
            conversation_id=conversation_id,
            turn_number=turn_number,
            felt_signature=felt_signature.tolist(),
            language_output=llm_output,
            success_metrics=success_metrics,
            metadata={
                'zone': felt_state.get('zone', 0),
                'polyvagal_state': felt_state.get('polyvagal_state', 'unknown'),
                'v0_energy': felt_state.get('v0_energy', 0.0),
                'nexus_count': felt_state.get('nexus_count', 0),
                'meta_atoms_active': felt_state.get('meta_atom_count', 0)
            }
        )

        # Add to memory
        self.memory.append(record)

        # Auto-save every 10 records
        if len(self.memory) % 10 == 0:
            self._save_memory()

        return record

    def _compute_57d_signature(self, felt_state: Dict[str, Any]) -> np.ndarray:
        """
        Extract 57-dimensional felt-state signature.

        Parallel to DAE 3.0's 57D grid transformation signature:
        - 11 organs × 4D = 44D (activation, intensity, polarity, confidence)
        - 13D context (v0, satisfaction, zone, polyvagal[3], meta_atoms, nexuses,
                       coherence, inflation, collapse, safety, convergence_cycles)

        Args:
            felt_state: Complete felt-state dictionary

        Returns:
            np.ndarray: 57-dimensional signature vector
        """
        organ_sig = []

        # Extract 11 organs × 4D = 44D
        organ_coherences = felt_state.get('organ_coherences', {})
        organ_intensities = felt_state.get('organ_intensities', {})
        organ_polarities = felt_state.get('organ_polarities', {})
        organ_confidences = felt_state.get('organ_confidences', {})

        for organ in self.ORGAN_NAMES:
            # Activation (coherence)
            organ_sig.append(organ_coherences.get(organ, 0.0))

            # Intensity
            organ_sig.append(organ_intensities.get(organ, 0.0))

            # Polarity (-1 to 1)
            organ_sig.append(organ_polarities.get(organ, 0.0))

            # Confidence
            organ_sig.append(organ_confidences.get(organ, 0.5))

        # Extract 13D context
        # One-hot encode polyvagal state (3 dimensions)
        polyvagal_state = felt_state.get('polyvagal_state', 'unknown')
        polyvagal_onehot = self._one_hot_polyvagal(polyvagal_state)

        context_sig = [
            felt_state.get('v0_energy', 0.0),
            felt_state.get('satisfaction', 0.0),
            felt_state.get('zone', 0) / 5.0,  # Normalize 1-5 → 0.2-1.0
            *polyvagal_onehot,  # 3 dimensions
            felt_state.get('meta_atom_count', 0) / 10.0,  # Normalize (typical max: 5-10)
            felt_state.get('nexus_count', 0) / 20.0,  # Normalize (typical max: 10-20)
            felt_state.get('field_coherence', 0.0),
            felt_state.get('signal_inflation', 0.0),
            felt_state.get('temporal_collapse', 0.0),
            felt_state.get('safety_gradient', 1.0),
            felt_state.get('convergence_cycles', 0) / 5.0  # Normalize (typical max: 3-5)
        ]

        # Combine: 44D + 13D = 57D
        full_signature = np.array(organ_sig + context_sig, dtype=np.float32)

        assert len(full_signature) == 57, f"Signature must be 57D, got {len(full_signature)}D"

        return full_signature

    def _one_hot_polyvagal(self, state: str) -> List[float]:
        """One-hot encode polyvagal state."""
        states = ['ventral', 'sympathetic', 'dorsal']
        if state not in states:
            return [0.0, 0.0, 0.0]  # Unknown state

        idx = states.index(state)
        onehot = [0.0, 0.0, 0.0]
        onehot[idx] = 1.0
        return onehot

    def get_statistics(self) -> Dict[str, Any]:
        """Get current recording statistics."""
        if not self.memory:
            return {
                'total_records': 0,
                'epochs_covered': [],
                'mean_signature_norm': 0.0,
                'unique_conversations': 0
            }

        epochs = set(r.epoch for r in self.memory)
        conversations = set(r.conversation_id for r in self.memory)

        # Compute mean signature norm
        signatures = np.array([r.felt_signature for r in self.memory])
        mean_norm = np.linalg.norm(signatures, axis=1).mean()

        return {
            'total_records': len(self.memory),
            'epochs_covered': sorted(list(epochs)),
            'mean_signature_norm': float(mean_norm),
            'unique_conversations': len(conversations),
            'records_per_epoch': {
                epoch: sum(1 for r in self.memory if r.epoch == epoch)
                for epoch in sorted(epochs)
            }
        }

    def get_records_by_epoch(self, epoch: int) -> List[FeltLanguageRecord]:
        """Retrieve all records from a specific epoch."""
        return [r for r in self.memory if r.epoch == epoch]

    def get_records_by_zone(self, zone: int) -> List[FeltLanguageRecord]:
        """Retrieve all records from a specific zone (1-5)."""
        return [r for r in self.memory if r.metadata.get('zone') == zone]

    def _load_memory(self) -> List[FeltLanguageRecord]:
        """Load memory from persistent storage."""
        if not Path(self.storage_path).exists():
            return []

        try:
            with open(self.storage_path, 'r') as f:
                data = json.load(f)
                return [
                    FeltLanguageRecord(**record)
                    for record in data.get('records', [])
                ]
        except Exception as e:
            print(f"⚠️ Failed to load felt language memory: {e}")
            return []

    def _save_memory(self):
        """Save memory to persistent storage."""
        try:
            # Ensure directory exists
            Path(self.storage_path).parent.mkdir(parents=True, exist_ok=True)

            data = {
                'metadata': {
                    'created': datetime.now().isoformat(),
                    'total_records': len(self.memory),
                    'format_version': '1.0',
                    'purpose': 'Felt-language learning corpus for organic grammar emergence'
                },
                'records': [asdict(record) for record in self.memory]
            }

            with open(self.storage_path, 'w') as f:
                json.dump(data, f, indent=2)

        except Exception as e:
            print(f"⚠️ Failed to save felt language memory: {e}")

    def clear_memory(self, confirmation: str = None):
        """
        Clear all recorded memories (use with caution!).

        Args:
            confirmation: Must be "YES_DELETE_ALL" to confirm
        """
        if confirmation != "YES_DELETE_ALL":
            raise ValueError("Must provide confirmation='YES_DELETE_ALL' to clear memory")

        self.memory = []
        self._save_memory()
        print(f"✅ Cleared all felt-language memory from {self.storage_path}")
